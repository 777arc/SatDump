#include "logger.h"
#include "gdal_priv.h"
#include <filesystem>
#include "common/geodetic/projection/proj_file.h"
#define cimg_use_png
#define cimg_display 0
#include "CImg.h"

int main(int argc, char *argv[])
{
    // SatDump init
    initLogger();

    if (argc < 4)
    {
        logger->error("This tool allows converting .georef files and an image generated by SatDump into a GeoTIFF file, commonly used for this sort of data.");
        logger->error(std::string(argv[0]) + " input_image.png input_georef.georef output_geotiff.tiff");
        return 1;
    }

    if (!std::filesystem::exists(argv[1]))
    {
        logger->error("Input image does not exists");
        return 1;
    }
    logger->info("Loading image " + std::string(argv[1]));
    cimg_library::CImg<unsigned short> src_image(argv[1]);

    if (!std::filesystem::exists(argv[2]))
    {
        logger->error("Input georef does not exists");
        return 1;
    }
    logger->info("Loading georef " + std::string(argv[2]));
    std::shared_ptr<geodetic::projection::proj_file::GeodeticReferenceFile> geofile = geodetic::projection::proj_file::readReferenceFile(argv[2]);

    //std::string gcpArguments;
    std::vector<GDAL_GCP> gdal_gcps; // Ground control points

    if (geofile->file_type == geodetic::projection::proj_file::LEO_TYPE)
    {
        logger->info("Computing LEO GCPs...");

        geodetic::projection::proj_file::LEO_GeodeticReferenceFile leofile = *((geodetic::projection::proj_file::LEO_GeodeticReferenceFile *)geofile.get());
        std::shared_ptr<geodetic::projection::LEOScanProjectorSettings> settings = leoProjectionRefFile(leofile);
        geodetic::projection::LEOScanProjector projector(settings);

        for (int y = 0; y < src_image.height(); y += 20)
        {
            for (int x = 0; x < src_image.width(); x += (src_image.width() / 30))
            {
                geodetic::geodetic_coords_t latlon;
                projector.inverse(x, y, latlon);
                //gcpArguments += "-gcp " + std::to_string(x) + " " + std::to_string(y) + " " + std::to_string(latlon.lon) + " " + std::to_string(latlon.lat) + " ";
                gdal_gcps.push_back(GDAL_GCP{"", "", double(x), double(y), latlon.lon, latlon.lat, 0});
            }
        }
    }
    else
    {
        logger->info("Computing GEO GCPs...");
        logger->error("GEO support has not been implemented yet!");
    }

    logger->info("Done! Generating GeoTiff...");

    // Let GDAL load import / export modules
    GDALAllRegister();

    // Create a new GeoTIFF dataset
    GDALDataset *dataset = GetGDALDriverManager()->GetDriverByName("GTiff")->Create(argv[3], src_image.width(), src_image.height(), src_image.spectrum(), GDT_UInt16, NULL);
    dataset->SetGCPs(gdal_gcps.size(), gdal_gcps.data(), "");
    dataset->SetProjection("epsg:4326");

    // Feed the image in
    for (int b = 0; b < src_image.spectrum(); b++)
    {
        for (int y = 0; y < src_image.height(); y++)
        {
            for (int x = 0; x < src_image.width(); x++)
            {
                dataset->GetRasterBand(b + 1)->RasterIO(GF_Write, 0, y, src_image.width(), 1,
                                                        &src_image[src_image.height() * src_image.width() * b + y * src_image.width()],
                                                        src_image.width(), 1, GDT_UInt16, 0, 0);
            }
        }
    }

    if (src_image.spectrum() == 3)
    {
        dataset->GetRasterBand(1)->SetColorInterpretation(GCI_RedBand);
        dataset->GetRasterBand(2)->SetColorInterpretation(GCI_GreenBand);
        dataset->GetRasterBand(3)->SetColorInterpretation(GCI_BlueBand);
    }

    GDALClose(dataset);

    logger->info("Done! Exiting...");
}